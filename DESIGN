`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Company: 
// Engineer: 
// 
// Create Date: 12.01.2026 18:33:55
// Design Name: 
// Module Name: modules
// Project Name: 
// Target Devices: 
// Tool Versions: 
// Description: 
// 
// Dependencies: 
// 
// Revision:
// Revision 0.01 - File Created
// Additional Comments:
// 
//////////////////////////////////////////////////////////////////////////////////


module mem(
    input  [3:0] wrt_data,
    output reg [3:0] rd_data,
    input rd_clk,wrt_clk,wrt_en,rd_en,wrt_full,
    input [2:0] rd_ptr,wrt_ptr
    );
    (* ram_style = "block" *)
    reg [3:0] mem [0:7];

    always @(posedge wrt_clk) begin
      if(wrt_en && !wrt_full) begin
        mem[wrt_ptr] <= wrt_data;
        end 
    end

  always @(posedge rd_clk) begin
    if (rd_en)
        rd_data <= mem[rd_ptr];
end

             
    
endmodule


module b2g(
    input [3:0] b,
    output reg [3:0] g
    );
    always @(*)
    begin
     g[3]<= b[3];
     g[2]<= b[2]^b[3];
     g[1]<= b[1]^b[2];
     g[0]<= b[0]^b[1];
     end
     
endmodule


module g2b(
  input  [3:0] g,
  output reg [3:0] b
);
   always @(*)
   begin 
       b[3] <= g[3];
       b[2] <= g[3] ^ g[2];
       b[1] <= g[3] ^ g[2] ^ g[1];
       b[0] <= g[3] ^ g[2] ^ g[1] ^ g[0];
   end
endmodule


module rd_src(
    input        rd_clk,
    input        rd_rst,
    output reg   rd_empty,
    output reg [3:0] rd_ptrf,
  input  [3:0] wrt_ptr2,   // synced gray code write
    input  [3:0] rd_ptr
);
  wire rd_empty_next;
    wire [3:0] rd_ptr_next;
    wire [3:0] rd_gray_next;
	
    assign rd_ptr_next = rd_ptr + 1;
    b2g g1(.b(rd_ptr_next), .g(rd_gray_next));
  assign rd_empty_next=(rd_gray_next == wrt_ptr2);
    always @(posedge rd_clk) begin
        if (rd_rst) begin
            rd_empty <= 1'b1;
            rd_ptrf  <= 4'b0000;
        end
        else begin
            rd_empty <= rd_empty_next;
            if (~rd_empty)
                rd_ptrf <= rd_ptr_next;
            else
                rd_ptrf <= rd_ptr;
        end
    end
endmodule


module wrt_src(
    input  [3:0] wrt_ptr, 
  input  [3:0] rptr2,// synced read gray
    input        wrt_clk,
    input        wrt_rst,
    output reg   wrt_full,
   output reg [3:0] wrt_ptrf
);
    wire [3:0] wrt_ptr_next;
    wire [3:0] wrt_gray_next;
    wire       full_next;
    
  	assign wrt_ptr_next = wrt_ptr + 1;
    b2g g1 (.b(wrt_ptr_next), .g(wrt_gray_next));
    
    assign full_next =
        (wrt_gray_next == {~rptr2[3:2], rptr2[1:0]});

    always @(posedge wrt_clk) begin
        if (wrt_rst) begin
            wrt_full <= 1'b0;
            wrt_ptrf <= 4'b0000;
        end
        else begin
            wrt_full <= full_next;
              if (!full_next) begin
                wrt_ptrf <= wrt_ptr_next;  
              end
              else begin
                  wrt_ptrf <= wrt_ptr;      
              end
        end
    end
endmodule


module stg_synth(
    input [3:0]gray_in,
    input clk,
    input rst,
    output reg [3:0] gray_out
    );
    reg [3:0] q;
    always @(posedge clk) begin
            if (rst) begin
                q        <= 4'b0;
                gray_out <= 4'b0;
            end else begin
                q        <= gray_in;
                gray_out <= q;
            end
    end
    
endmodule
